# 객체 분해

1. 당면한 문제를 해결하기 위해서는 장기 기억(정보)보다 단기 기억(정보)가 더 필요하다.
2. 모든 것을 단기 기억으로 저장할 수 없다. -> 불필요한 정보를 제거하고 핵심적인 정보만 남기는 것, 추상화가 필요하다.
3. 추상화의 방법 중 하나 : 분해 
4. 분해의 목적 : 단기 기억안에서 한번에 처리할 수 있는 규모로 문제로 나누는 것.

## 프로시저 추상화와 데이터 추상화

1. 추상화 메커니즘 2가지  - 프로시저, 데이터 추상화
2. 프로시저 추상화는 기능 분해, 알고리즘 분해라고 부른다.
3. 데이터 추상화는 데이터를 중심으로 타입을 추상화 하는 것, 프로시저를 추상화하는 것으로 나뉠 수 있다.

## 프로시저 추상화와 기능 분해

- 프로시저 추상화는 정보은닉 체계를 구축하는데 한계가 있다.
- 최상위 기능을 수행하기 위한 기능을 작은 단위로 쪼개나간다.
- 예) 최상위 기능 - 직원의 급여를 계산한다를 위해, 소득 세율 입력, 이를 바탕으로 급여 계산 및 출력 단위
- 하향식 기능 분해의 문제점이 존재 : 변경에 취약하다. 그 중에서도 `결합도`가 높다는 것이 큰 문제.
- 최상위 메인 함수가 존재하는 애플리케이션 존재하지 않는다.
- 비지니스 로직과 화면 출력 로직이 결합, 관심사의 분리가 필요하다.
- 설계 단계에서 시스템의 실행 순서가 결정된다. 실행 순서는 빈번한 변경의 대상이다.
- 데이터 변경으로 인한 파급 효과 - 아르바이트 타입의 추가로, 조건문 추가 시작.


## 모듈

- 시스템 변경 관리의 기본 전략: `변경의 방향`에 맞춰 시스템을 분해
- `정보 은닉`이 필요하다. `복잡성` `변경 가능성`을 감춰야 한다.
- 모듈의 장점 : 1. 변경의 파급이 내부로 한정 2. 관심사의 분리 3. 변수 중복 방지
- 모듈의 단점 : 인스턴스 개념을 제공하지 않는다. 

## 데이터 추상화와 추상 데이터 타입

- 급여 관리 시스템의 Employee를 추상 데이터 타입으로 전환
- 한계 : 결국 조건문으로 내부 로직이 구현된다. 결국, 새로운 타입이 추가시 수정해야할 범위가 넓다.

## 클래스

- 추상 데이터 타입과 클래스는 동일하지 않다.
- 차이점은 `다형성`
- 추상 데이터 타입은 타입을 추상화 한 것이고, 클래스는 절차를 추상화 한 것이다.

## 추상 데이터 타입과 클래스

- 클래스는 타입에 따라서 절차들을 추상화한다.
- Employee 라는 추상 클래스를 상속 받아 정규, 아르바이트 직원을 구현
- 이에 따라 세부 오퍼레이션은 타입에 따라 구현
- 추상 데이터 타입의 오퍼레이션에서 조건문으로 구현된 것이 클래스 타입에서는 다형성으로 대체
- 조건문을 기피하는 이유는 변경
- 두 방법에 정답은 없고 애플리케이션의 특성에 따라 적절하게 선택 후 구현하는 것이 중요.

