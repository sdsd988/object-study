# 메세지와 인터페이스

## 도입

1. 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체(수행하는 책임)을 지향해야 한다.
2. 클래스 중심의 사고가 아니라, 메세지와 인터페이스 중심의 책임과 협력적 사고
3. 객체가 수신하는 메세지들이 객체의 퍼블릭 인터페이스를 구성하기에, 메세지 설계 원칙이 필요하다.


## 협력과 메세지

1. 클라이언트 - 서버 모델
- 메세지를 매개로 요청(클라이언트) 응답(서버)의 조합이 두 객체 사이의 협력을 결정한다.

2. 메세지와 메세지 전송

- 수신자, 오퍼레이션명, 인자

3. 메세지와 메서드

- 메세지와 메서드의 차이, 실제 구현되는 것이 메서드 추상화된 것이 메세지
- 객체는 메시지와 메서드를 실행 시점에 연결

4. 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메세지의 집합 
- 오퍼레이션 : 인터페이스에 포함된 메세지, 행동에 대한 추상화, 구현 코드가 제왼 경우를 지칭
- 시그니처 : 오퍼레이션의 이름과 파라미터 목록을 합친 것

## 인터페이스와 설계 품질
- 최소한의, 추상적인 인터페이스 구현
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
  - 다미터 법칙, 묻지 말고 시켜라, 의도를 드러내는 인터페이스, 명령-쿼리 분리

### 디미터 법칙

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한(캡슐화)
- 특정 조건을 만족하는 경우에만, 메세지를 전송

### 묻지 말고 시켜라

- 메세지를 전송하는 수신자(객체)의 상태를 변경하는 것이 아니라 필요한 것을 묻는 것.
- 객체지향의 기본 원칙은 함께 변경될 확률이 높은 정보와 행도을 하나의 단위로 통합하는 것
- 상태를 묻는 것이 아니라(예: 가방에 티켓이 존재하는가? )가 아니라 행동을 요청

### 의도를 드러내는 인터페이스

- 방법1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것
  - 효과 1. : 메세지 이름으로 메세지의 행동을 파악할 수 있다.
  - 효과 2. : 캡슐화를 지킬 수 있다.
- 방법2. 어떻게가 아니라 `무엇`을 하는지를 드러내는 것
 - 효과 1. 객체가 협력 안에서 수행하는 책임을 중심으로 사고할 수 있다.

## 원칙의 함정

### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다.
- Stream 활용 문법 활용은 디미터 법칙 위반이 아니다.
- 객체의 내부 구현이 외부에 노출되지 않는다면, 위반하는 것이 아니다.

### 결합도와 응집도의 충돌

- 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존한게 된다.
- 예를 들면, 묻는 대상이 자료 구조인 경우 디미터 법칙을 적용하지 않는 것이 옳을 수 있다.
- 결국 트레이드 오프

## 명령-쿼리 분리 원칙

루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
프로시저(== 명령) : 내부의 상태를 변경하는 루틴의 종류
함수(== 쿼리) : 필요한 값을 계산해서 반환하는 루틴의 종류

- 원칙의 요지: 명령이면서 쿼리인 오퍼레이션은 좋지 않다.
- 기계로서의 객체 메타포: 명령 이전의 쿼리는 동일한 결과이지만, 명령 이후의 쿼리는 이전과 다른 결과를 제공한다. 분리의 이유.

### 반복 일정의 명령과 쿼리 분리하기
- Event 객체의 isSatisfied 객체는 쿼리인 동시에 명령이다. -> 버그를 발생
- 객체지향 패러다임에서는 부수효과를 피할 수 없다. 따라서, 명령-쿼리 분리 원칙을 잘 활용하는 것이 중요하다.

### 책임에 초점을 맞춰라

- 디미터 법칙, 묻지말고 시켜라 스타일은 메세지를 선택하고 그 후에 매세지를 처리할 객체를 선책함으로서 구현
- 명령-쿼리 분리 원칙과 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러낼 수 있는 방법은 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 하는 것.

