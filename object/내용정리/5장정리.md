# 책임 할당 하기

##  책임 주도 설계를 향해

책임 중심의 설계의 원칙

1. 데이터보다 행동을 먼저 결정
   - 객체는 데이터를 저장하는 것이 아니라, 협력하기 위해 존재
2. 협력이라는 문맥 안에서 책임을 결정
   - 책임은 객체의 입장이 아니라 참여하는 협력에 적합해야 한다.

### 협력을 시작하는 주체는 메시지 전송자, 즉 클라이언트이다.

메세지를 결정하고 객체를 선택 -> 메시지 송신자(클라이언트)는 메세지 수신자(다른 객체)에 대한 어떤 가정도 할 수 없다.
-> 자연스럽게 캡슐화가 된다.

## 책임 할당을 위한 GRASP 패턴

- 책임을 할당해야 할 때 가장 먼저 고민해야 하는 것은 도메인 개념
- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.
- 책임의 할당 : 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각
- 정보 전문가 패턴 : 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당
  - 필요한 정보를 가진 객체들로 책임이 분산되기 떄문에 응집력이 높아진다
  - 예매 하라 메세지 처리에 적합한 객체는? 
  - 스스로 처리할 수 없는 작업은 협력을 통해 해결
- 높은 응집도, 낮은 결합도 패턴
  - 도메인 개념에서 서로 속성으로 포함되어 있는 객체부터 협력을 시작
  - 책임을 분산시키지 말 것
- 창조자 패턴
  - A 객체를 포함하거나 참조, 기록, 사용, 초기화에 필요한 데이터를 가지고 있는 객체에 책임을 할당 할 것


## 구현을 통한 검증

- DiscountCondition 개선하기 (클래스 분리하기)
  - 변경의 이유에 따라 클래스를 분리해야 한다.
  - 인스턴스 변수가 초기화되는 시점으로 판단하는 방법 즉 함께 초기화 되는 속성을 기준으로 코드를 분리
  - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리
  - 기간과 순번 2종류의 클래스로 분리하면 결합도 증가
- 다형성 패턴
  - 동일한 역할을 수행하는 두 객체
  - 역할을 구현하기 위해 사용되는 추상 클래스와 인터페이스
  - 구현을 공유하면 추상 클래스, 역할을 대체하는 객체들의 책임의 정의 인터페이스
- 변경 보호 패턴
  - 하나의 변경이 다른 객체에 영향을 주거나, 정보를 노출시키지 않도록
  - 책임 할당의 관점에서 캡슐화

## 책임 주도 설계의 대안

처음부터 적절한 책임을 할당하고 설계하는 것은 어렵다.
아무것도 없는 상태에서 책임과 협력에 관해 고민하지 말고 일단 실행되는 코드를 작성한 이후에 `리팩토링` 할 것
- 리팩토링 추천 방법 - 메서드 응집도 높이기, 객체 자율적으로 만들기 
- 메서드 응집도가 낮으면
  - 이해하는데 많은 시간이 필요하고,
  - 수정해야 할 부분을 찾기 힘들고
  - 일부 로직 변경시 그 영향을 파악하기 힘들고
  - 일부 로직을 재사용하는 것이 힘들고
  - 로직 재사용시 복붙하므로 코드 중복 증가
- 객체를 자율적으로 만드는 방법
  - 어떤 클래스의 접근자 메서드를 사용하는지 파악
- 앞에 정리한 다양한 패턴 등을 활용하여, 꾸준한 리팩토링에 대해 고민하고 적용하는 것이 중요할 듯