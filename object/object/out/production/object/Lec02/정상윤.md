# 객체지향 프로그래밍

## 협력, 객체, 클래스

### 객체 지향 프로그래밍에서 중요하게 생각해야 할 사항

1. '클래스' 중심이 아니라 `객체` 중심으로 생각할 것.
   - 클래스는 상태와 행동을 공유하는 객체들을 추상화한 것 - `코드 단위`
   - 객체는 어떤 상태와 행동을 가지는 것 - `실행 단위`
2. '객체'를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 볼 것.
    - 뒷 부분에 나오는 `상속과 다형성`과 관련

도메인 - 소프트웨어는 사용가자가 원하는 `문제`를 해결하기 위해 만들어진다. 도메인이란, `문제`를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 의미한다.

객체 지향 프로그래밍의 장점 : `객체`를 활용하여 프로그램의 처음부터 끝까지 추상화 기법(상속과 다형성)을 사용할 수 있기 때문


### 자율적인 객체

#### 인스턴스 변수의 가시성은 private, 메서드의 가시성은 public, 이를 통해 클래스의 경계를 구분한다. Why? `객체의 자율성을 보장하기 위해서`


1. 객체는 상태와 행동을 함께 가지는 복합적인 존재이다.
2. 객체는 스스로 판단하고 행동하는 자율적인 존재이다.

`캡슐화` : 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶은 것

`접근제어` : 접근 수정자를 통해 객체 내부에 대한 접근을 통제하는 것

- 이 둘의 목적은, 객체를 자율적인 존재로 만들기 위함
- `객체가 자율적인 존재이다.` == `객체가 통제되고 있다.`
- 객체가 자율적이고, 유연하기 위해서는 독립적이어야 한다.
- 스스로 자신의 상태를 결정할 수 있어야 하며, 자신의 생각을 외부에 공개되는 것 혹은 외부에서 자신의 상태에 개입하려는 것을 통제.

캡슐화와 접근 제어를 통해 객체를 두 부분으로 나눈다. 
1. 퍼블릭 인터페이스(Public Interface) 
2. 구현(Implementation)

#### 프로그래머의 자유, 설계의 중요성, 인터페이스와 구현의 분리

클래스 작성자
- 새로운 데이터 타입을 프로그램에 추가하는 역할
- 클라이언트 프로그래머에게 필요한 부분은 공개하고, 불필요한 부분은 은닉

클라이언트 프로그래머  
- 클래스 작성자가 작성한 것을 활용하는 역할
- 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축



#### 협력에 관한 짧은 이야기

- 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다는 것이 지금까지 주요 내용.
- 그러나, 객체간 협력을 위해서는 퍼블릭 인터페이스를 통해 외부로부터 내부 상태에 접근할 수 있도록 적절하게 허용해야 한다.
- 메세지 전송과 수신의 차이

#### 할인 정책과 할인 조건
- 템플릿 메서드 패턴 : 부모 클래스에 기본적인 알고리즘을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴

#### 오버라이딩과 오버로딩
- 오버라이딩 : 부모 클래스에 3정의된 같은 이름 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는 경우, 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 외부에서는 부모 클래스의 메서드가 보이지 않는다,
- 오버로딩 : 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다. 원래의 메서드를 가리지 않기 때문에 공존한다.

### 상속과 다형성

1. 의존성
- 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.
- 코드의 의존성(`Movie`는 `DiscountPolicy`에 의존)과 실행 시점의 의존성(`Movie`는 `AmountDiscountPolicy` or `PercentDiscountPolicy`에 의존)
- 코드(클래스)의 의존성과 실행 시점(객체)의 의존성은 동일하지 않을 수 있다.
- 코드의 의존성과 실행시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워지지만, 유연해지고 확장 가능해진다. 

#### 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 빠르고 쉽게 만드는 방법

#### 상속과 인터페이스

- 상속의 목적은 메서드나 인스턴스 변수를 재사용하는 것이 아닌 부모 클래스가 제공하는 모든 인터페이스를 물려받을 수 있기 때문
- 인터페이스는 객체가 이해할 수 있는 목록을 정의한다.
- 자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 떄문에 부모 클래스 대신 사용될 수 있다. 즉 업캐스팅이 가능.

#### 다형성

- 메세지와 메서드는 다르다, 한 객체가 동일한 메세지를 전송하지만 실행 시점에 어떤 메서드가 실행될 지는 수신하는 객체의 클래스에 따라 다르다. 
- 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 `다형성`이라고 한다.
- 다형성이 가능한 이유는 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 활용
- 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다. 지연 바인딩, 동적 바인딩
- 구현 상속과 인터페이스 상속

#### 추상화와 유연성
- 같은 계층에 속하는 클래스들이 공통적으로 가질 수 있는 인터페이스를 정의하고, 구현의 일부 혹은 전체를 자식 클래스가 결정할 수 있도록 결정권을 위임하는 것.
- 첫 번째 장점 : 요구 사항을 간결하고, 명확하게 서술할 수 있다.
- 두 번째 장점:  유연한 설계가 가능하다.
- 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다.


#### 상속

- 상속의 단점은 1. 캡슐화를 위반한다. 2. 설계를 유연하지 못하게 만든다.
- 캡슐화를 위반한다는 것은, 상속을 활용하게 되면 개발자는 부모 클래스의 내부 구조를 파악해야 한다. 결고적으로 부모 클래스의 구현이 자식 클래스에게 노출되므로 캡슐화 약화.
- 설계를 유연하지 못하게 만든다는 것은, 객체 사이의 관계가 컴파일 시점에 결정되게 한다는 것.
- 객체 지향의 유연성, 다형성은 객체 사이의 관계가 컴파일 시점이 아닌 실행 시점에 결정될 수 있다는 것을 활용했다.

#### 합성
- 상속이 가진 두가지 문제점을 해결할 수 있다.
- 상속이 나쁘다, 합성이 좋다가 아니라 두 개념의 특징을 이해하고 활용해야 한다는 점이 중요하다.
